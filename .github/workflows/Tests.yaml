# Distributed under the MIT License.
# See LICENSE.txt for details.

# Continuous integration tests that pull requests are required to pass. This
# workflow can also be dispatched manually to tag and release versions.
name: Tests

# Set any defaults for the runs below.
# - use bash as the default shell since this is almost certainly what
#   is always expected. We use regular expressions in a few places
#   that rely on bash.
defaults:
  run:
    shell: bash

# Note that by default the jobs only run on the base repository, testing pull
# requests and merge commits. Enable GitHub Actions in your fork's repository
# settings to also run the tests on every push to one of your branches.
on:
  # We run all jobs when pull requests are opened, commits are pushed, or pull
  # requests are re-opened after being closed.
  # The jobs triggered by this event run on the base repository of the pull
  # request, so they have access to its caches.
  pull_request:
  # We run those jobs that require no information about a pull request (e.g.
  # unit tests) also on `push` events. This setup tests merge commits into
  # `develop` and also builds up caches on `develop` that can be re-used by PRs.
  # It also runs the jobs on forks if they have GitHub Actions enabled.
  push:
    branches-ignore:
      - gh-pages
  # Allow running the workflow manually to run tests and optionally release a
  # version on success (see the dev guide on "Automatic versioning")
  workflow_dispatch:
    inputs:
      release_version:
        description: >
          Enter a version name YYYY.MM.DD[.TWEAK] to create a release on success
        required: false
        default: ''
      timezone:
        description: >
          Timezone used for validating the version name. The release must be
          approved by the end of the day in the specified timezone. See
          /usr/share/zoneinfo for a list of possible values.
        required: false
        default: 'America/Los_Angeles'
      clear_ccache:
        description: >
          Enter 'yes' without quotes to clear ccache before running
        required: false
        default: ''


# Cancel all other queued or in-progress runs of this workflow when it is
# scheduled, so repeated pushes to a branch or a PR don't block CI. Repeated
# pushes to 'develop' and 'release' are not canceled, so every merge commit is
# tested.
concurrency:
  group: ${{ github.ref }}
  cancel-in-progress: ${{ github.ref != 'refs/heads/develop'
    && github.ref != 'refs/heads/release' }}

jobs:
  # Build all test executables and run unit tests on a variety of compiler
  # configurations.
  unit_tests:
    name: Unit tests
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        # We have a sparse clang test configuration to reduce the amount of
        # GitHub cache space we use. GCC being the production compiler on
        # supercomputers means we need to thoroughly test it.
        compiler:
          - clang-11
          - clang-13
        build_type: [Debug]
        include:
        #   # Generate code coverage report for a single build
        #   # Note: currently disabled because it exceeds the available disk space
        #   # - compiler: gcc-9
        #   #   build_type: Debug
        #   #   COVERAGE: ON
        #   #   TEST_TIMEOUT_FACTOR: 3
        #   # This configuration seems to run consistently slower than newer gcc
        #   # or clang builds, so we increase the test timeout a bit
        #   - compiler: gcc-10
        #     build_type: Debug
        #     TEST_TIMEOUT_FACTOR: 2
        #   # Add a test without PCH to the build matrix, which only builds core
        #   # libraries. Building all the tests without the PCH takes very long
        #   # and the most we would catch is a missing include of something that's
        #   # in the PCH.
        #   # Use this test also to build and test all input files with "normal"
        #   # or higher priority. The other configurations only test input files
        #   # with "high" priority to reduce the total build time.
        #   - compiler: clang-10
        #     build_type: Debug
        #     use_pch: OFF
        #     unit_tests: OFF
        #     input_file_tests_min_priority: "normal"
        #   # Full clang-10 build to catch any incompatibilities.
        #   - compiler: clang-10
        #     build_type: Release
        #   # Test with ASAN
          - compiler: clang-11
            build_type: Debug
            # When building with ASAN we also need python bindings to be
            # disabled because otherwise we get link errors. See issue:
            # https://github.com/sxs-collaboration/spectre/issues/1890
            # So we are also using this build to test building without Python
            # bindings enabled.
            ASAN: ON
            BUILD_PYTHON_BINDINGS: OFF
            MEMORY_ALLOCATOR: JEMALLOC
        #   # Test building with static libraries. Do so with clang in release
        #   # mode because these builds use up little disk space compared to GCC
        #   # builds or clang Debug builds
        #   - compiler: clang-11
        #     build_type: Release
        #     BUILD_SHARED_LIBS: OFF
        #     use_xsimd: OFF
        #     MEMORY_ALLOCATOR: JEMALLOC
          # Test with MPI version of charm
          - compiler: clang-13
            build_type: Debug
            CHARM_ROOT: /work/charm_7_0_0/mpi-linux-x86_64-smp-clang
            # MPI running tests is a bit slower than multicore
            TEST_TIMEOUT_FACTOR: 3

    container:
      image: sxscollaboration/spectre:ci
      env:
        # We run unit tests with the following compiler flags:
        # - `-Werror`: Treat warnings as error.
        # - `-march=x86-64`: Make sure we are building on a consistent
        #   architecture so caching works. This is necessary because GitHub
        #   may run the job on different hardware.
        CXXFLAGS: "-Werror"
        # We make sure to use a fixed absolute path for the ccache directory
        CCACHE_DIR: /work/ccache
        # Control the max cache size. We evict unused entries in a step below to
        # make sure that each build only uses what it need of this max size.
        CCACHE_MAXSIZE: "2G"
        # Control the compression level. The ccache docs recommend at most level
        # 5 to avoid slowing down compilation.
        CCACHE_COMPRESS: 1
        CCACHE_COMPRESSLEVEL: 5
        # We hash the content of the compiler rather than the location and mtime
        # to make sure the cache works across the different machines
        CCACHE_COMPILERCHECK: content
        # Rewrite absolute paths starting with this base dir to relative paths
        # before hashing. This is needed to reuse the cache for the formaline
        # test below, which builds in a different directory.
        CCACHE_BASEDIR: $GITHUB_WORKSPACE
        # These vars are to allow running charm with MPI as root inside the
        # container which arises from using the "--privileged" flag just below.
        OMPI_ALLOW_RUN_AS_ROOT: 1
        OMPI_ALLOW_RUN_AS_ROOT_CONFIRM: 1
      # See https://lists.cs.illinois.edu/lists/arc/charm/2018-10/msg00011.html
      # for why we need this
      options: --privileged
    steps:
      - name: Record start time
        id: start
        run: |
          echo "time=$(date +%s)" >> "$GITHUB_OUTPUT"
      - name: Checkout repository
        uses: actions/checkout@v3
      # Work around https://github.com/actions/checkout/issues/760
      - name: Trust checkout
        run: |
          git config --global --add safe.directory $GITHUB_WORKSPACE
      # Assign a unique cache key for every run.
      # - We will save the cache using this unique key, but only on the develop
      #   branch. This way we regularly update the cache without filling up the
      #   storage space with caches from other branches.
      # - To restore the most recent cache we provide a partially-matched
      #   "restore key".
      - name: Restore ccache
        uses: actions/cache/restore@v3
        id: restore-ccache
        env:
          CACHE_KEY_PREFIX: "ccache-${{ matrix.compiler }}-\
${{ matrix.build_type }}-pch-${{ matrix.use_pch || 'ON' }}"
        with:
          path: /work/ccache
          key: "${{ env.CACHE_KEY_PREFIX }}-${{ github.run_id }}"
          restore-keys: |
            ${{ env.CACHE_KEY_PREFIX }}-
      - name: Configure ccache
        # Print the ccache configuration and reset statistics
        run: |
          ccache -pz
      - name: Clear ccache
        # Clear ccache if requested
        # if: >
        #   github.event_name == 'workflow_dispatch'
        #     && github.event.inputs.clear_ccache == 'yes'
        run: |
          ccache -C
      - name: Configure build with cmake
        # Notes on the build configuration:
        # - We don't need debug symbols during CI, so we turn them off to reduce
        #   memory usage.
        run: >
          mkdir build && cd build

          if [[ ${{ matrix.compiler }} =~ (gcc|clang)-([0-9\.]+) ]]; then
            CC=${BASH_REMATCH[1]}-${BASH_REMATCH[2]};
            if [[ ${BASH_REMATCH[1]} = gcc ]]; then
              CXX=g++-${BASH_REMATCH[2]};
              FC=gfortran-${BASH_REMATCH[2]};
            else
              CXX=clang++-${BASH_REMATCH[2]};
              FC=gfortran-9;
            fi
          fi

          BUILD_PYTHON_BINDINGS=${{ matrix.BUILD_PYTHON_BINDINGS }}
          BUILD_SHARED_LIBS=${{ matrix.BUILD_SHARED_LIBS }}
          PYTHON_EXECUTABLE=${{ matrix.PYTHON_EXECUTABLE }}
          CMAKE_EXECUTABLE=${{ matrix.CMAKE_EXECUTABLE }}
          MATRIX_CHARM_ROOT=${{ matrix.CHARM_ROOT }}
          ASAN=${{ matrix.ASAN }}
          MEMORY_ALLOCATOR=${{ matrix.MEMORY_ALLOCATOR }}
          UBSAN_UNDEFINED=${{ matrix.UBSAN_UNDEFINED }}
          UBSAN_INTEGER=${{ matrix.UBSAN_INTEGER }}
          USE_PCH=${{ matrix.use_pch }}
          USE_XSIMD=${{ matrix.use_xsimd }}
          COVERAGE=${{ matrix.COVERAGE }}
          TEST_TIMEOUT_FACTOR=${{ matrix.TEST_TIMEOUT_FACTOR }}
          INPUT_FILE_MIN_PRIO=${{ matrix.input_file_tests_min_priority }}

          ${CMAKE_EXECUTABLE:-'cmake'}
          -D CMAKE_C_COMPILER=${CC}
          -D CMAKE_CXX_COMPILER=${CXX}
          -D CMAKE_Fortran_COMPILER=${FC}
          -D CMAKE_CXX_FLAGS="${CXXFLAGS} ${{ matrix.EXTRA_CXX_FLAGS }}"
          -D OVERRIDE_ARCH=x86-64
          -D CHARM_ROOT=${MATRIX_CHARM_ROOT:-$CHARM_ROOT}
          -D CMAKE_BUILD_TYPE=${{ matrix.build_type }}
          -D DEBUG_SYMBOLS=OFF
          -D UNIT_TESTS_IN_TEST_EXECUTABLES=OFF
          -D SPECTRE_INPUT_FILE_TEST_MIN_PRIORITY=${INPUT_FILE_MIN_PRIO:-'high'}
          -D STRIP_SYMBOLS=ON
          -D STUB_EXECUTABLE_OBJECT_FILES=ON
          -D STUB_LIBRARY_OBJECT_FILES=ON
          -D USE_PCH=${USE_PCH:-'ON'}
          -D USE_XSIMD=${USE_XSIMD:-'ON'}
          -D USE_CCACHE=ON
          -D COVERAGE=${COVERAGE:-'OFF'}
          -D BUILD_PYTHON_BINDINGS=${BUILD_PYTHON_BINDINGS:-'ON'}
          -D Python_EXECUTABLE=${PYTHON_EXECUTABLE:-'/usr/bin/python3'}
          -D BUILD_SHARED_LIBS=${BUILD_SHARED_LIBS:-'ON'}
          -D ASAN=${ASAN:-'OFF'}
          -D UBSAN_UNDEFINED=${UBSAN_UNDEFINED:-'OFF'}
          -D UBSAN_INTEGER=${UBSAN_INTEGER:-'OFF'}
          -D MEMORY_ALLOCATOR=${MEMORY_ALLOCATOR:-'SYSTEM'}
          -D SPECTRE_UNIT_TEST_TIMEOUT_FACTOR=${TEST_TIMEOUT_FACTOR:-'1'}
          -D SPECTRE_INPUT_FILE_TEST_TIMEOUT_FACTOR=${TEST_TIMEOUT_FACTOR:-'1'}
          -D SPECTRE_PYTHON_TEST_TIMEOUT_FACTOR=${TEST_TIMEOUT_FACTOR:-'1'}
          -D CMAKE_INSTALL_PREFIX=/work/spectre_install
          -D BUILD_DOCS=OFF
          --warn-uninitialized
          $GITHUB_WORKSPACE 2>&1 | tee CMakeOutput.txt 2>&1
      - name: Check for CMake warnings
        working-directory: build
        run: |
          ! grep -A 6 "CMake Warning" ./CMakeOutput.txt
      # - name: Build unit tests
      #   if: matrix.unit_tests != 'OFF'
      #   working-directory: /work/build
      #   run: |
      #     make -j2 unit-tests
      # - name: Run unit tests
      #   if: matrix.unit_tests != 'OFF' && matrix.COVERAGE != 'ON'
      #   working-directory: /work/build
      #   run: |
      #     # We get occasional random timeouts, repeat tests to see if
      #     # it is a random timeout or systematic.
      #     #
      #     # We run ctest -L unit before build test-executables to make
      #     # sure that all the unit tests are actually built by the
      #     # unit-tests target.
      #     ctest -j2 -L unit --output-on-failure --repeat after-timeout:3
      # - name: Run unit tests with coverage reporting
      #   if: matrix.COVERAGE == 'ON'
      #   working-directory: /work/build
      #   run: |
      #     make unit-test-coverage
      #     rm -r docs/html/unit-test-coverage
      # - name: Upload coverage report to codecov.io
      #   if: matrix.COVERAGE == 'ON'
      #   uses: codecov/codecov-action@v3
      #   with:
      #     files: /work/build/tmp/coverage.info
      #     # Display the job as failed if upload fails (defaults to false for
      #     # some reason)
      #     fail_ci_if_error: true
      #   # We currently don't require codecov in our guidelines, so don't fail
      #   # the CI build if codecov fails to upload
      #   continue-on-error: true
      # Build the executables in a single thread to reduce memory usage
      # sufficiently so they compile on the GitHub-hosted runners
      - name: Build executables
        if: matrix.COVERAGE != 'ON'
        working-directory: build
        run: |
          export CCACHE_DEBUG=1
          export CCACHE_DEBUGDIR=/work/ccache-debug-og
          make -j2 DomainStructure
          find /work/ccache-debug-og -type f -name '*.ccache-input-[cdp]' -delete
      # # Delete unused cache entries before uploading the cache
      # - name: Clean up ccache
      #   if: github.ref == 'refs/heads/develop'
      #   run: |
      #     now=$(date +%s)
      #     job_duration=$((now - ${{ steps.start.outputs.time }}))
      #     ccache --evict-older-than "${job_duration}s"
      # # Save the cache after everything has been built. Also save on failure or
      # # on cancellation (`always()`) because a partial cache is better than no
      # # cache.
      # - name: Save ccache
      #   if: always() && github.ref == 'refs/heads/develop'
      #   uses: actions/cache/save@v3
      #   with:
      #     path: /work/ccache
      #     key: ${{ steps.restore-ccache.outputs.cache-primary-key }}
      # - name: Print size of build directory
      #   working-directory: /work/build
      #   run: |
      #     ls | xargs du -sh
      #     du -sh .
      - name: Diagnose ccache
        run: |
          ccache -s
      # - name: Run non-unit tests
      #   if: matrix.COVERAGE != 'ON'
      #   working-directory: /work/build
      #   run: |
      #     # We get occasional random timeouts, repeat tests to see if
      #     # it is a random timeout or systematic
      #     ctest -j2 -LE unit --output-on-failure --repeat after-timeout:3
      # - name: Install
      #   # Coverage and ASAN builds are larger, so skip install to avoid running
      #   # out of disk space
      #   if: matrix.COVERAGE != 'ON' && matrix.ASAN != 'ON'
      #   working-directory: /work/build
      #   # Make sure the `install` target runs without error. We could add some
      #   # basic smoke tests here to make sure the installation worked.
      #   run: |
      #     make install
      # - name: Print size of install directory
      #   if: matrix.COVERAGE != 'ON' && matrix.ASAN != 'ON'
      #   working-directory: /work/spectre_install
      #   # Remove files post-install to reduce disk space for later on.
      #   run: |
      #     ls | xargs du -sh
      #     du -sh .
      #     rm -r ./*
      - name: Prepare for upload
        working-directory: /work
        run: |
          tar -cf ccache-debug-og.tar --directory ccache-debug-og .
      - name: Upload ccache debugdir2
        uses: actions/upload-artifact@v3
        with:
          name: ccache-debug-og-${{ matrix.compiler }}
          path: /work/ccache-debug-og.tar
      - name: del
        working-directory: /work
        run: |
          rm -rf ccache-debug-og.tar ccache-debug-og
      - name: Test formaline tar can be built
        # - We only run the formaline tests in debug mode to reduce total build
        #   time in CI.
        # - We do run for all compilers, though, because formaline injects data
        #   at the linking stage, which means we are somewhat tied to the
        #   compiler version.
        # - We make sure to use the same compiler flags as the full build above
        #   so ccache is able to speed up the build.
        if: matrix.build_type == 'Debug'
        working-directory: build
        run: >
          make EvolveBurgers -j2

          if [ ! -f ./bin/EvolveBurgers ]; then
            echo "Could not find the executable EvolveBurgers";
            echo "which we use for testing formaline";
            exit 1
          fi

          # We disable ASAN's leak sanitizer because Charm++ has false
          # positives that would cause the build to fail. We disable
          # leak sanitizer for the ctest runs inside CMake anyway.

          ASAN_OPTIONS=detect_leaks=0 ./bin/EvolveBurgers
          --dump-source-tree-as spectre_src --dump-only

          mkdir spectre_src;
          mv spectre_src.tar.gz spectre_src;
          cd spectre_src;
          tar xf spectre_src.tar.gz;
          mkdir build;
          cd build

          if [[ ${{ matrix.compiler }} =~ (gcc|clang)-([0-9\.]+) ]]; then
            CC=${BASH_REMATCH[1]}-${BASH_REMATCH[2]};
            if [[ ${BASH_REMATCH[1]} = gcc ]]; then
              CXX=g++-${BASH_REMATCH[2]};
              FC=gfortran-${BASH_REMATCH[2]};
            else
              CXX=clang++-${BASH_REMATCH[2]};
              FC=gfortran-9;
            fi
          fi

          BUILD_PYTHON_BINDINGS=${{ matrix.BUILD_PYTHON_BINDINGS }}
          PYTHON_EXECUTABLE=${{ matrix.PYTHON_EXECUTABLE }}
          MATRIX_CHARM_ROOT=${{ matrix.CHARM_ROOT }}
          MEMORY_ALLOCATOR=${{ matrix.MEMORY_ALLOCATOR }};
          USE_PCH=${{ matrix.use_pch }};
          USE_XSIMD=${{ matrix.use_xsimd }}

          cmake
          -D CMAKE_C_COMPILER=${CC}
          -D CMAKE_CXX_COMPILER=${CXX}
          -D CMAKE_Fortran_COMPILER=${FC}
          -D CMAKE_CXX_FLAGS="${CXXFLAGS} ${{ matrix.EXTRA_CXX_FLAGS }}"
          -D OVERRIDE_ARCH=x86-64
          -D BUILD_SHARED_LIBS=ON
          -D CHARM_ROOT=${MATRIX_CHARM_ROOT:-$CHARM_ROOT}
          -D CMAKE_BUILD_TYPE=${{ matrix.build_type }}
          -D DEBUG_SYMBOLS=OFF
          -D UNIT_TESTS_IN_TEST_EXECUTABLES=OFF
          -D STRIP_SYMBOLS=ON
          -D STUB_EXECUTABLE_OBJECT_FILES=ON
          -D STUB_LIBRARY_OBJECT_FILES=ON
          -D USE_PCH=${USE_PCH:-'ON'}
          -D USE_XSIMD=${USE_XSIMD:-'ON'}
          -D USE_CCACHE=ON
          -D BUILD_PYTHON_BINDINGS=${BUILD_PYTHON_BINDINGS:-'ON'}
          -D Python_EXECUTABLE=${PYTHON_EXECUTABLE:-'/usr/bin/python3'}
          -D MEMORY_ALLOCATOR=${MEMORY_ALLOCATOR:-'SYSTEM'}
          -D BUILD_DOCS=OFF
          ..

          export CCACHE_LOGFILE=/work/ccache.log

          export CCACHE_DEBUG=1

          export CCACHE_DEBUGDIR=/work/ccache-debug-formaline

          make DomainStructure -j2

          find /work/ccache-debug-formaline -type f -name '*.ccache-input-[cdp]' -delete
      - name: Upload ccache logfile
        uses: actions/upload-artifact@v3
        with:
          name: ccache-log-${{ matrix.compiler }}
          path: /work/ccache.log
      - name: Prepare for upload
        working-directory: /work
        run: |
          tar -cf ccache-debug-formaline.tar --directory ccache-debug-formaline .
      - name: Upload ccache debugdir2
        uses: actions/upload-artifact@v3
        with:
          name: ccache-debug-formaline-${{ matrix.compiler }}
          path: /work/ccache-debug-formaline.tar
      - name: Diagnose ccache
        run: |
          ccache -s
