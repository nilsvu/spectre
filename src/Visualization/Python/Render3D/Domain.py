# Distributed under the MIT License.
# See LICENSE.txt for details.

import click
import rich


def _parse_step(ctx, param, value):
    if value is None:
        return None
    if value.lower() == "first":
        return 0
    if value.lower() == "last":
        return -1
    return int(value)


@click.command(name="domain")
@click.argument(
    "xmf_file",
    type=click.Path(exists=True, file_okay=True, dir_okay=False, readable=True),
)
@click.argument(
    "hi_res_xmf_file",
    type=click.Path(exists=True, file_okay=True, dir_okay=False, readable=True),
    required=False,
)
@click.option(
    "--output",
    "-o",
    type=click.Path(writable=True),
    required=True,
    help="Output file. Include extension such as '.png'.",
)
@click.option(
    "--time-step",
    "-t",
    callback=_parse_step,
    default="first",
    show_default=True,
    help=(
        "Select a time step. Specify '-1' or 'last' to select the last time"
        " step."
    ),
)
@click.option(
    "--animate", is_flag=True, help="Produce an animation of all time steps."
)
@click.option("zoom_factor", "--zoom", help="Zoom factor.", default=1.0)
@click.option(
    "--camera-theta",
    type=float,
    default=0.0,
    help="Viewing angle from the z-axis in degrees.",
    show_default=True,
)
@click.option(
    "--clip-origin",
    nargs=3,
    type=float,
    default=(0.0, 0.0, 0.0),
    help="Origin of the clipping plane",
    show_default=True,
)
@click.option(
    "--clip-normal",
    nargs=3,
    type=float,
    default=(0.0, 0.0, 1.0),
    help="Normal of the clipping plane",
    show_default=True,
)
def render_domain_command(
    xmf_file,
    hi_res_xmf_file,
    output,
    time_step,
    animate,
    zoom_factor,
    camera_theta,
    clip_origin,
    clip_normal,
):
    """Renders a 3D domain with elements and grid lines

    This rendering is a starting point for visualizations of the domain
    geometry, e.g. for publications.

    XMF_FILE is the path to the XMF file that references the simulation data.
    It is typically generated by the 'generate-xdmf' command.
    You can also provide a second XMF file with higher resolution data, which
    is used to render the outlines of elements to make them smoother.
    """
    import paraview.simple as pv

    # Load data
    volume_data = pv.XDMFReader(
        registrationName="VolumeData", FileNames=[xmf_file]
    )
    if hi_res_xmf_file:
        hi_res_volume_data = pv.XDMFReader(
            registrationName="HiResVolumeData", FileNames=[hi_res_xmf_file]
        )

    render_view = pv.GetActiveViewOrCreate("RenderView")
    render_view.UseLight = 0
    render_view.UseColorPaletteForBackground = 0
    render_view.Background = 3 * [1.0]
    render_view.OrientationAxesVisibility = 0

    def clip(**kwargs):
        clip = pv.Clip(**kwargs)
        clip.ClipType = "Plane"
        clip.ClipType.Origin = clip_origin
        clip.ClipType.Normal = clip_normal
        return clip

    # Show grid
    grid = clip(registrationName="Grid", Input=volume_data)
    grid_display = pv.Show(grid, render_view)
    grid_display.Representation = "Surface With Edges"
    grid_display.LineWidth = 1.0
    grid_display.EdgeColor = 3 * [0.6]
    # The following line works around a failure in `pv.ColorBy(..., None)`
    grid_display.ColorArrayName = ("POINTS", None)
    pv.ColorBy(grid_display, None)

    # Show outline
    outline_data = hi_res_volume_data if hi_res_xmf_file else volume_data
    outline = clip(registrationName="OutlineClip", Input=outline_data)
    outline_display = pv.Show(outline, render_view)
    outline_display.Representation = "Feature Edges"
    outline_display.LineWidth = 2.0
    outline_display.DiffuseColor = 3 * [0.0]
    outline_display.AmbientColor = 3 * [0.0]
    # The following line works around a failure in `pv.ColorBy(..., None)`
    outline_display.ColorArrayName = ("POINTS", None)
    pv.ColorBy(outline_display, None)

    # Set resolution
    layout = pv.GetLayout()
    layout.SetSize(1920, 1080)

    # Configure camera
    camera = pv.GetActiveCamera()
    camera.SetFocalPoint(*clip_origin)
    camera.Elevation(-camera_theta)
    pv.ResetCamera()
    camera.Zoom(zoom_factor)

    if animate:
        pv.SaveAnimation(output, render_view)
    else:
        render_view.ViewTime = volume_data.TimestepValues[time_step]
        pv.SaveScreenshot(output, render_view)


if __name__ == "__main__":
    render_domain_command(help_option_names=["-h", "--help"])
